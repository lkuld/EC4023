---
title: "Tutorial 3: Inspect and clean data"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(EC4023)
library(stringr)
knitr::opts_chunk$set(echo = FALSE)
```


##  Inspect data

The package `EC4023` contains a raw dataset of all listings in the Irish Residential Property Price Register in May 2023.  

Our first goal is to understand the size of this dataset, stored as `may23_df`.  

- As a `data.frame`, the **length** of `may23_df` corresponds to the number of columns.  
- `length(may23_df[, 1])` gives the length of the first column, which is the number of rows.  
- We can also use `ncol()` and `nrow()` to directly check the number of columns and rows.  

---

**Task:** Use the functions `length()`, `ncol()`, and `nrow()` to explore the dataset.  
Then use `head(may23_df)` to view the first rows.  

```r
length(may23_df)        # number of columns
ncol(may23_df)          # number of columns
nrow(may23_df)          # number of rows
length(may23_df[, 1])   # number of rows (length of first column)

head(may23_df)          # view the first rows
```

```{r ex-1, exercise=TRUE}


```
```{r ex-1-solution}
length(may23_df)
ncol(may23_df)
nrow(may23_df)
length(may23_df[,1])

```

Next, use the `summary()` function on the dataset to obtain a summary of all variables.  
You can also apply it to individual vectors, for example `summary(may23_df$County)`.

```{r ex-2, exercise=TRUE}


```

The output shows the same info for all variables: each vector has length 5,174 and R read every column as `character`.  
That’s fine for variables like address or county. **Prices**, however, should be numeric to compute statistics (e.g., the mean).

Below, we force R to convert the `Price` column to numeric.  


```{r ex-3, exercise=TRUE}
may23_df$price_numeric <- as.numeric(may23_df$Price....)
head(may23_df$price_numeric)
```

Most likely because the entries in the price column aren’t *pure numbers* — they include non-numeric characters (e.g. the euro symbol `€`, commas as thousands separators, or other text).  
When you call `as.numeric()` on such strings, R can’t parse them and returns `NA` ('Not Available') with the warning *“NAs introduced by coercion”*.

You can confirm by inspecting the first values: `head(may23_df$Price....)` or `may23_df$Price....[1:10]`

```{r ex-4, exercise=TRUE}


```

R is (rightly) conservative here: since the original price data contains non-numeric characters (a euro sign or unrecognised symbol in your encoding and commas as thousands separators), it won’t convert to numeric and instead returns `NA`.  
If you decide these non-numeric characters are safe to remove, you can proceed by **cleaning** the data.


## Clean data

We will clean our data using *regular expressions*.^[See https://en.wikipedia.org/wiki/Regular_expression.] Regular expressions are not R specific and are used in many instances that involve text, for example search engines. A regular expression is a sequence of characters that describes how to match text patterns. 

For instance, we might want to search for the word 'recognise' in a text but also allow for alternative spellings ending in '-ize' or '-ise'. The regular expression 'recogni[sz]e' would match either case as the hard bracket symbolizes to match any of the characters inside.

If we try to extract years from a text, '[0-9]{4}' would match any four digit number.  [0-9] is the same as [012345678] or [a-d] the same as [abcd] following the built in sequence of characters. The 4 in curly brackets signifies 4 times the preceding character(s). 

As another example, '1[89][0-9]{2}' matches any number between 1800 and 1999. The expression can be read as follows: first a '1', then a 8 or 9, then two numbers between 0 and 9.

Other regular expression options include the beginning of a character string, a new line, or specific pattern (not) to follow. A great resource to look up options and explore is the website https://www.regular-expressions.info.

To use regular expressions in R, we will use the functions of the package `stringr`. The package provides functionality that simplifies dealing with text patterns. For instance, `str_detect(string, pattern)` outputs `TRUE` if the pattern is found in the string and `FALSE` otherwise. 

**Task:** Modify the code so that all elements are matched (all `TRUE`).

```{r ex-5, exercise=TRUE}
fruits <- c('apple', 'Apple')
str_detect(string = fruits,pattern = '[Aa]pple')

work <- c('labor', 'labour')
str_detect(string = work,pattern = 'labor')

```

Returning to the property price register, we want to **delete all non-numeric characters** from the original price data and then convert to numeric.  
With `stringr::str_remove_all()`, the pattern `[^0-9]` matches any character that is **not** a digit (0–9) due to the ^ symbol in front, so it strips €, commas, spaces, etc.


```{r ex-6, exercise=TRUE}
may23_df$price_clean <- str_remove_all(string = may23_df$Price...., pattern = '[^0-9]')
may23_df$price_numeric <- as.numeric(may23_df$price_clean)

may23_df$price_numeric[1:15]
```

Can you use the same approach to extract all house numbers from the addresses? If not, why?

### Variable names

You might have noticed the awkward variable names generated by R. The function `names()` tells you all names associated with an object. While you should be careful, you can also change the variable names this way. For example, we could quickly remove (multiple) dots at the end of a name using `names(may23_df) <- str_remove(names(may23_df), '[.]+$')`.

Why does the pattern '[.]+$' work? 

  * `.` is a special regex character that matches *any* character.
To match a literal dot, we either place it in brackets `[.]` or escape it as `\.`.
* `+` means “one or more” of the preceding token (here, the dot).
* `$` anchors the match to the **end** of the string, so only trailing dots are removed.

Hence, `"[.]+$"` means: *match one or more literal dots at the end of the string*.

```{r ex-7, exercise=TRUE}
names(may23_df)
names(may23_df) <- str_remove(names(may23_df), '[.]+$')
names(may23_df)
```


**Task:** 
Use regular expression to extract all years from the date vector using the function `str_extract(string, pattern)`. 
Hint: the name changes made above are not carried over. If you are stuck, look up how to match years a few lines up.

```{r ex-8, exercise=TRUE}

```

```{r ex-8-solution}
may23_df$year <- str_extract(may23_df$Date.of.Sale..dd.mm.yyyy., '[0-9]{4}')

```

You could also extract day and month this way, however, there are easier options.

## Dates

An option to deal with the date vector is to use the built-in date format (there are alternative options using packages). 

Have a look at the help option of the function `as.Date()` (type `?as.Date`). In the help article, we see that we can specify the date format in case that R does not output our dates properly. 

Indeed, it messes up the dates. Therefore, we start by first printing a few dates to see whether we can recognise a pattern.

```{r ex-9, exercise=TRUE}
head(may23_df$Date.of.Sale..dd.mm.yyyy.)
```

This shows the dates are inputted as a two digit number for day of the month, a two digit number for the month, and a four digit number for the year. In addition, these are separated by '/'. 

We can now transform our dates as follows (note the capital Y).

```{r ex-10, exercise=TRUE}
may23_df$date <- as.Date(x=may23_df$Date.of.Sale..dd.mm.yyyy., format= '%d/%m/%Y')
head(may23_df$date)
```

The new format allows us to use some helpful functions, for instance to find the earliest date or, using additional packages, the month or day. Importantly, this will allow us to deal with the time dimension properly, for instance to plot a statistic over time.

```{r ex-11, exercise=TRUE}
may23_df$date <- as.Date(x=may23_df$Date.of.Sale..dd.mm.yyyy., format= '%d/%m/%Y')
min(may23_df$date)
```
