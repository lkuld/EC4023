---
title: "Tutorial 2: Data structures and types"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(EC4023)
knitr::opts_chunk$set(echo = FALSE)
```


# Organise data

## Vectors

*In the last tutorial we encountered two common data types: numbers (e.g., 1, 6, …) and character strings (e.g., "blue", "five", "5", "fdbv 47.. df"). We organised multiple elements into **vectors**—ordered collections where, for example, we can access the third element by its position.*

Below are two vectors: a numeric vector and a character vector (the latter indicated by quotes `'` or `"`).  
If you are not sure what type an R object is, use `class()`.

**Task:** Determine the type of each vector in the box below.

```{r vec-1, exercise=TRUE}

numeric_vector <- c(2,54,5,7)
character_vector <- c('two', 'flower','tree','2')

```


```{r vec-1-solution}
numeric_vector <- c(2,54,5,7)
character_vector <- c('two', 'flower','tree','2')

class(numeric_vector)
class(character_vector)
```

Next, output the third element of each vector using the `vector[3]` notation. 

```{r vec-1b, exercise=TRUE}

numeric_vector <- c(2,54,5,7)
character_vector <- c('two', 'flower','tree','2')

```


```{r vec-1b-solution}

numeric_vector[3]
character_vector[3]
```


You can combine two vectors or add additional elements using the function `c()`.  
Run the following code:  

```{r vec-2, exercise=TRUE}

numeric_vector <- c(2,54,5,7)
character_vector <- c('two', 'flower','tree','2')

numeric_vector_2 <- c(numeric_vector, 3)
numeric_vector_2

c(numeric_vector, character_vector)
```

In the last line, we combined our character and numeric vectors. R automatically converted all numeric elements into character strings.  
This happens because vectors can only contain a single data type. While numbers can be converted to characters, the reverse is usually not possible.  

(This holds true outside of R as well—for instance, *5* can be the name of a room. Importantly, room 5 plus room 3 does not equal room 8. While this may seem obvious, it reflects a common mistake in statistics: not everything that looks like a number should be treated as a number.)


## Data frames

Typically, we need more than one vector to organise our data.  
For example, we might want to study the **height** and **age** of a group of children.  
- The first vector contains the children’s heights in cm, where the first element is the height of child 1, the second element the height of child 2, and so on.  
- The second vector contains their ages in the same order.  

A straightforward way to organise these observations is to create a **table**:  
- **Columns** correspond to categories (variables), such as height or age.  
- **Rows** correspond to the observation units, in this case, the children.  

We may also want to add a third column with the name or identifier for each child.  
The standard data structure for such a table in R is called a `data.frame`.  

The box below defines and outputs a simple data frame:


```{r data-frame, exercise=TRUE}

name <- c('Peter', 'Helen', 'Ana', 'Sean', 'Chris', 'Mary')
age <- c(8,7,9,7,7,8)
height <- c(125,133,151,145,140,134)

age_height_df <- data.frame(name, age, height)

age_height_df
```

This brings us to a first look at the data we will use for our term project.  
A cleaned-up subset of the Irish property data has been added to this tutorial as a `data.frame` called `limerick_property_df`.  

The `data.frame` consists of three variables (vectors): **year**, **address**, and **price**.  

**Tasks:**  

1. Output the variable names using the function `names()`:  `names(limerick_property_df)`

2. Display the whole dataset by typing its name: `limerick_property_df`.


*(If you cannot see the price column, click on the triangle on the right.)*



```{r prop-data, exercise=TRUE}


```

If we want to calculate the mean price, we first need to access the `price` vector.  
One way to do this is by using the dollar sign `$` after the name of the `data.frame`.  

The box below outputs the prices in this way.  
Change the code to calculate, save, and print the mean of the vector using the function `mean()`.

```{r price, exercise=TRUE, eval=TRUE}
limerick_property_df$price

```

```{r price-solution}
mean_price <- mean(limerick_property_df$price)
mean_price
```

A second way to access one or more vectors in a `data.frame` is by using the square bracket `[]` notation we used earlier for vectors.  
Since a `data.frame` has two dimensions (rows and columns), we can subset it in both directions: `[row, column]`.  

Examples:  
- `limerick_property_df[1, 2]` returns the first row of the second column.  
- `limerick_property_df[c(1,2,3,4), 1]` returns the first four rows of the first column.  
- Leaving one dimension empty selects *all* elements of that dimension:  
  - `limerick_property_df[c(1,2), ]` gives the first two rows.  
  - `limerick_property_df[, 3]` gives the third column.  

**Task:** Complete the code below to output the first two addresses.  

```{r subset, exercise=TRUE}
limerick_property_df[]

```

Since our columns have names, we can also access them directly.  
For example:  
- `limerick_property_df[ , 'address']`  
- `limerick_property_df[c(1,2,3), 'price']`  

Because we often want to access multiple rows, R provides shortcuts:  
- `a:b` creates a vector from *a* to *b*.  
- For instance, `1:5` is the same as `c(1, 2, 3, 4, 5)`.  

**Task:** Save the first ten prices as an object called `first_prices`.  
Then calculate the mean of these prices.

```{r subset2, exercise=TRUE}
limerick_property_df[]

```

```{r subset2-solution}
first_prices <- limerick_property_df[1:10, 'price']
mean(first_prices)

```

## Logical constants & Boolean expressions

Our property `data.frame` contains observations from multiple years.  
Use the function `table()` to check how many observations there are per year.  

```{r obs-year, exercise=TRUE}


```

```{r obs-year-solution}
table(limerick_property_df$year)

```

We now want to create a subset of our data that only contains observations from 2020.  
It is not practical to just use row numbers for this operation. Instead, we use a **Boolean expression**, which produces `TRUE` when an observation meets a condition (e.g., year = 2020) and `FALSE` otherwise.  
The result is a vector of logical constants (`TRUE`/`FALSE`) with the same length as the vector of years.  

Logical constants are a third data type in R, besides numeric and character data, and play a huge role in data work, since we often manipulate or subset data based on conditions.  

The box below illustrates the principle.  
We have a vector of fruits: `c("apple", "pear", "orange")`.  
We want to subset this vector using a `TRUE`/`FALSE` vector—first directly, and then with a Boolean expression.  

You can use two notations:  
1. A double equal sign: `fruits == "apple"`  
2. The `%in%` operator: `fruits %in% "apple"`  

The second option is more flexible because it allows comparisons with multiple elements, e.g. `fruits %in% c("apple", "orange", "strawberry")`.  

**Task:** Complete the code below with a Boolean expression that is equivalent to the direct way.  


```{r true-fruit, exercise=TRUE}
fruits <- c('apple', 'pear', 'orange')

fruits[c(TRUE, FALSE, FALSE)]
fruits[]

```

```{r true-fruit-solution}
fruits[fruits %in% 'apple']

```

If you want to invert a `TRUE`/`FALSE` vector, simply place an exclamation mark `!` in front of it.  
For example:  

```r
!c(TRUE, FALSE, FALSE)
!fruits %in% c("apple")
```

Now let’s apply these principles to the house price data.
Create a Boolean expression that outputs `TRUE` for all years equal to 2020.

```{r true-year, exercise=TRUE}


```

```{r true-year-solution}
true_2020 <- limerick_property_df$year %in% 2020 # or limerick_property_df$year == 2020
true_2020
```

We could use this vector to subset our data so that it contains only observations from 2020.  
(Note the comma after the expression: we are subsetting rows here):  

```r
data2020 <- limerick_property_df[limerick_property_df$year %in% 2020, ]
```
**Task:**  
Create a subset of limerick_property_df that excludes all observations from 2020 using a Boolean expression.
(Remember: you can negate an expression using `!`.)

```{r subset2020, exercise=TRUE}
not2020 <- limerick_property_df[,]
not2020
```

```{r subset2020-solution}
condition <- !limerick_property_df$year %in% 2020
not2020 <- limerick_property_df[condition,] # or limerick_property_df %in% c(2018, 2019, 2021, 2022)
not2020
```

Your code is often easier to read if you first define the condition rather than writing it directly into the square brackets.  

Besides equality (`==`), there are three more useful operators:  
1. `!=` (does not equal)  
2. `>` (greater than)  
3. `<` (less than)  

---

**Task:**  
Calculate the mean year of all properties that sold for less than 200,000.  
Replace the question marks in the code below.  

```{r smallPrices, exercise=TRUE}
condition <- limerick_property_df$price ???
mean(limerick_property_df$year[condition])

```

```{r smallPrices-solution}
condition <- limerick_property_df$price < 200000
mean(limerick_property_df$year[condition])
```

We can combine multiple Boolean expressions using logical operators:  

- `&` for **and**  
  Example:  
  ```r
  limerick_property_df$price < 200000 & limerick_property_df$year == 2020
```

This is `TRUE` only if the price is below 200,000 **and** the year is 2020.

* `|` for **or**
  Example:

  ```r
  limerick_property_df$price < 200000 | limerick_property_df$year == 2020
  ```

  This is `TRUE` if either the price is below 200,000 **or** the year is 2020.

---

**Task:**  

Calculate the mean price for all properties that cost **either more than 300,000 or less than 150,000**.

```{r eitherPrices, exercise=TRUE}
condition1 <- ???
condition2 <- ???
condition_overall <- condition1 ??? condition2
mean(limerick_property_df$price[condition_overall])

```

```{r eitherPrices-solution}
condition1 <- limerick_property_df$price < 150000 
condition2 <- limerick_property_df$price > 300000
condition_overall <- condition1 | condition2
mean(limerick_property_df$price[condition_overall])

```

